# ********RoostGPT********
"""
Test generated by RoostGPT for test test_iii using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=main_6b7d89f7b9
ROOST_METHOD_SIG_HASH=main_105191a9d8


Scenario 1: Validate the correct winner is determined based on the score
Details:
  TestName: test_correct_winner_based_on_score
  Description: This test verifies that the function correctly determines the winner based on the scores of the two players.
Execution:
  Arrange: Prepare the environment with predefined scores of two players.
  Act: Invoke the who_won function with the predefined scores.
  Assert: Check if the function correctly determines the winner based on the scores.
Validation:
  This test is important to ensure that the game logic is correctly implemented and the winner is determined accurately.

Scenario 2: Validate correct toss result and choice of batting or bowling
Details:
  TestName: test_correct_toss_and_choice
  Description: This test verifies that the toss function works accurately and the player who wins the toss gets to choose batting or bowling.
Execution:
  Arrange: Prepare the environment with a predefined toss result.
  Act: Invoke the toss function and main function with the predefined toss result.
  Assert: Check if the player who won the toss gets to choose batting or bowling.
Validation:
  This test is important to ensure the toss function works as expected and the game proceeds accurately based on the toss result.

Scenario 3: Validate the game ends when the number of overs is reached
Details:
  TestName: test_game_ends_after_overs
  Description: This test verifies that the game ends after the specified number of overs is reached.
Execution:
  Arrange: Prepare the environment with a predefined number of overs.
  Act: Invoke the play_game function with the predefined number of overs.
  Assert: Check if the game ends after the specified number of overs is reached.
Validation:
  This test ensures that the game duration is controlled correctly according to the number of overs.

Scenario 4: Validate correct handling of invalid inputs
Details:
  TestName: test_handling_invalid_inputs
  Description: This test verifies that the function correctly handles invalid inputs.
Execution:
  Arrange: Prepare the environment with an invalid input.
  Act: Invoke the main function with the invalid input.
  Assert: Check if the function correctly handles the invalid input and exits the game.
Validation:
  This test ensures that the game handles invalid inputs gracefully without causing any errors or crashes.

Scenario 5: Validate correct score update after each over
Details:
  TestName: test_score_update_after_over
  Description: This test verifies that the scores of the players are correctly updated after each over.
Execution:
  Arrange: Prepare the environment with predefined scores and overs.
  Act: Invoke the play_game function with the predefined scores and overs.
  Assert: Check if the scores are correctly updated after each over.
Validation:
  This test ensures that the scoring system in the game works correctly and updates the scores accurately after each over.
"""

# ********RoostGPT********
import pytest
import random
from HandCricket.main import main, play_game, toss, who_won

class Test_MainMain:

    @pytest.mark.regression
    def test_correct_winner_based_on_score(self, monkeypatch):
        monkeypatch.setattr('builtins.input', lambda _: '1')
        monkeypatch.setattr('random.randint', lambda a, b: 1)
        assert who_won(50, 40) == 'Player 1 won'
        assert who_won(30, 60) == 'Player 2 won'
        assert who_won(50, 50) == 'The match ended in a draw'

    @pytest.mark.regression
    def test_correct_toss_and_choice(self, monkeypatch):
        monkeypatch.setattr('builtins.input', lambda _: '1')
        monkeypatch.setattr('random.randint', lambda a, b: 1)
        assert toss() == 1
        monkeypatch.setattr('random.randint', lambda a, b: 2)
        assert toss() == 2

    @pytest.mark.regression
    def test_game_ends_after_overs(self, monkeypatch):
        monkeypatch.setattr('builtins.input', lambda _: '1')
        monkeypatch.setattr('random.randint', lambda a, b: 1)
        player1_score, player2_score = play_game(2, '1', '2', 1)
        assert (player1_score is not None) and (player2_score is not None)

    @pytest.mark.regression
    def test_handling_invalid_inputs(self, monkeypatch):
        monkeypatch.setattr('builtins.input', lambda _: 'invalid')
        with pytest.raises(ValueError):
            main()

    @pytest.mark.regression
    def test_score_update_after_over(self, monkeypatch):
        monkeypatch.setattr('builtins.input', lambda _: '1')
        monkeypatch.setattr('random.randint', lambda a, b: 1)
        player1_score, player2_score = play_game(2, '1', '2', 1)
        assert (player1_score >= 0) and (player2_score >= 0)

# ********RoostGPT********
"""
Test generated by RoostGPT for test test_iii using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=user_turn_44c7d49cf6
ROOST_METHOD_SIG_HASH=user_turn_46f575d8c2


```
Scenario 1: Verify the correct increment of player's score when batting
Details:
  TestName: test_player_score_increment_batting
  Description: This test will verify that the player's score is correctly incremented when the player is batting and his chosen runs do not match the opponent's.
Execution:
  Arrange: Mock the input for the player's shot and the random generator for the opponent's runs. 
  Act: Call the user_turn function with the player's choice as "1" (batting).
  Assert: Check that the player's score is correctly incremented by the chosen runs.
Validation:
  It's crucial to ensure that the score is correctly updated during the game. This directly impacts the game result and thus, the business logic.

Scenario 2: Verify the player losing a wicket when batting
Details:
  TestName: test_player_wicket_loss_batting
  Description: This test will verify that the player loses a wicket when he is batting and his chosen runs match the opponent's.
Execution:
  Arrange: Mock the input for the player's shot and the random generator for the opponent's runs to be the same.
  Act: Call the user_turn function with the player's choice as "1" (batting).
  Assert: Check that the player's wickets are decremented by 1.
Validation:
  Ensuring the correct deduction of wickets is essential as it affects the flow of the game and the final result.

Scenario 3: Verify the correct increment of player's score when bowling
Details:
  TestName: test_player_score_increment_bowling
  Description: This test will verify that the player's score is correctly incremented when the player is bowling and his randomly generated runs do not match the opponent's.
Execution:
  Arrange: Mock the input for the player's delivery and the random generator for the player's runs.
  Act: Call the user_turn function with the player's choice as "2" (bowling).
  Assert: Check that the player's score is correctly incremented by the randomly generated runs.
Validation:
  This test ensures the correctness of the score update which influences the game's outcome.

Scenario 4: Verify the player losing a wicket when bowling
Details:
  TestName: test_player_wicket_loss_bowling
  Description: This test will verify that the player loses a wicket when he is bowling and his randomly generated runs match the opponent's.
Execution:
  Arrange: Mock the input for the player's delivery and the random generator for the player's runs to be the same.
  Act: Call the user_turn function with the player's choice as "2" (bowling).
  Assert: Check that the player's wickets are decremented by 1.
Validation:
  It's essential to validate the wicket deduction process as it directly affects the game's progression and final result.
  
Scenario 5: Verify the termination of the over after 6 balls
Details:
  TestName: test_over_termination
  Description: This test will verify that the over terminates after 6 balls, regardless of the number of wickets.
Execution:
  Arrange: Mock the inputs for the player's shots or deliveries.
  Act: Call the user_turn function with valid parameters.
  Assert: Check that the function returns after 6 iterations.
Validation:
  This scenario ensures that the game adheres to the rules of cricket, where each over consists of 6 balls.
  
Scenario 6: Verify the termination of the over when all wickets are lost
Details:
  TestName: test_over_termination_wickets
  Description: This test will verify that the over terminates when all wickets are lost, even if fewer than 6 balls have been played.
Execution:
  Arrange: Mock the inputs for the player's shots or deliveries to cause the loss of all wickets.
  Act: Call the user_turn function with valid parameters.
  Assert: Check that the function returns before 6 iterations.
Validation:
  This scenario ensures that the game adheres to the rules of cricket, where an over terminates if all wickets are lost.
```

"""

# ********RoostGPT********
import pytest
import random
from unittest.mock import patch
from main import user_turn

class Test_MainUserTurn:

    @pytest.mark.parametrize("player_choice, player_runs, opponent_runs, expected_score", [("1", 4, 2, 4)])
    @patch('builtins.input', side_effect=[4])
    @patch('random.randint', return_value=2)
    def test_player_score_increment_batting(self, input_mock, randint_mock, player_choice, player_runs, opponent_runs, expected_score):
        score, _ = user_turn(0, 1, player_choice, 0)
        assert score == expected_score

    @pytest.mark.parametrize("player_choice, player_runs, opponent_runs, expected_wickets", [("1", 4, 4, 0)])
    @patch('builtins.input', side_effect=[4])
    @patch('random.randint', return_value=4)
    def test_player_wicket_loss_batting(self, input_mock, randint_mock, player_choice, player_runs, opponent_runs, expected_wickets):
        _, wickets = user_turn(0, 1, player_choice, 0)
        assert wickets == expected_wickets

    @pytest.mark.parametrize("player_choice, player_runs, opponent_runs, expected_score", [("2", 4, 2, 4)])
    @patch('builtins.input', side_effect=["2", 2])
    @patch('random.randint', return_value=4)
    def test_player_score_increment_bowling(self, input_mock, randint_mock, player_choice, player_runs, opponent_runs, expected_score):
        score, _ = user_turn(0, 1, player_choice, 0)
        assert score == expected_score

    @pytest.mark.parametrize("player_choice, player_runs, opponent_runs, expected_wickets", [("2", 4, 4, 0)])
    @patch('builtins.input', side_effect=["2", 4])
    @patch('random.randint', return_value=4)
    def test_player_wicket_loss_bowling(self, input_mock, randint_mock, player_choice, player_runs, opponent_runs, expected_wickets):
        _, wickets = user_turn(0, 1, player_choice, 0)
        assert wickets == expected_wickets

    @patch('builtins.input', side_effect=[1, 2, 3, 4, 5, 6])
    @patch('random.randint', side_effect=[2, 3, 4, 5, 6, 1])
    def test_over_termination(self, input_mock, randint_mock):
        score, wickets = user_turn(0, 1, "1", 0)
        assert score == 21
        assert wickets == 1

    @patch('builtins.input', side_effect=[1, 2, 3, 4, 5, 6])
    @patch('random.randint', side_effect=[1, 2, 3, 4, 5, 6])
    def test_over_termination_wickets(self, input_mock, randint_mock):
        score, wickets = user_turn(0, 1, "1", 0)
        assert score == 0
        assert wickets == 0
